

local M = { }

local socket = require 'socket'
local url = require 'neturl'

function M.listen(port, ip)
	local server = socket.tcp()
	--server:setoption('reuseaddr', true)
  --server:setoption('tcp-nodelay', true)
	local s, e
	s, e = server:bind(ip or "127.0.0.1", port)
	if not s then
    LOG.e("BIND SERVER", e)
		os.exit(-1)
	end
	s, e = server:listen()
	if not s then LOG.e("LISTEN SERVER", e) end
	server:settimeout(0.2)

	return coroutine.create(function()
		local response
		local curConn, err
		local req
		repeat
			curConn, err = server:accept()
			if err ~= "timeout" and curConn then
				while not req do
					req, err = curConn:receive()
					if err then
						curConn:close()
            break
					end
					break
				end
			elseif err ~= "timeout" then LOG.e("ERROR ACCEPTING", err) end

			if req then
				req = url.parse(req)
        STATS.onClientServed()
        print("yield server")
				response = coroutine.yield(req)
        print("resume server")
				if response == "close socket" then
          curConn:shutdown("both")
          curConn:close()
          server:close()
          return
        elseif response then
					curConn:send(response)
          curConn:shutdown("both")
          curConn:close("both")
          response = nil
				end
      elseif curConn then
        print("no request?")
        curConn:send("\r\n\r\n")
      end

      req = nil
		until nil
	end)
end

return M
